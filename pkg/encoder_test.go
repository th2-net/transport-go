/*
 * Copyright 2023 Exactpro (Exactpro Systems Limited)
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package transport_test

import (
	"github.com/stretchr/testify/assert"
	transport "github.com/th2-net/transport-go/pkg"

	"testing"
	"time"
)

func TestEncoder_EncodeRaw(t *testing.T) {
	e := transport.NewEncoder(nil)
	e.EncodeRaw(transport.RawMessage{
		MessageId: transport.MessageId{
			SessionAlias: "alias",
			Sequence:     42,
			Direction:    transport.OutgoingDirection,
			Timestamp:    transport.TimestampFromTime(time.UnixMilli(1682420400000)),
		},
		Protocol: "protocol",
		Metadata: map[string]string{
			"key": "value",
		},
		Body: []byte{41, 42, 43, 44, 45},
	}, 0)
	res := e.CompleteBatch("group", "book")

	expected := []byte{
		0x32, // batch
		0x8d, 0x00, 0x00, 0x00,
		0x33, // groups
		0x75, 0x00, 0x00, 0x00,
		0x28, // group
		0x70, 0x00, 0x00, 0x00,
		0x29, // msg list
		0x6b, 0x00, 0x00, 0x00,
		0x14, // raw msg
		0x66, 0x00, 0x00, 0x00,
		0x0a, // msg id
		0x33, 0x00, 0x00, 0x00,
		0x67, // alias
		0x05, 0x00, 0x00, 0x00,
		0x61, 0x6c, 0x69, 0x61, 0x73,
		0x68, // direction
		0x01, 0x00, 0x00, 0x00,
		0x02,
		0x69, // seq
		0x08, 0x00, 0x00, 0x00,
		0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6a, // sub seq
		0x00, 0x00, 0x00, 0x00,
		0x6b, // timestamp
		0x0c, 0x00, 0x00, 0x00,
		0xb0, 0xb2, 0x47, 0x64, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x0b, // metadata
		0x12, 0x00, 0x00, 0x00,
		0x02, // key
		0x03, 0x00, 0x00, 0x00,
		0x6b, 0x65, 0x79,
		0x02, // value
		0x05, 0x00, 0x00, 0x00,
		0x76, 0x61, 0x6c, 0x75, 0x65,
		0x0c, // protocol
		0x08, 0x00, 0x00, 0x00,
		0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
		0x15, // body
		0x05, 0x00, 0x00, 0x00,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d,
		0x65, // book
		0x04, 0x00, 0x00, 0x00,
		0x62, 0x6f, 0x6f, 0x6b,
		0x66, // group
		0x05, 0x00, 0x00, 0x00,
		0x67, 0x72, 0x6f, 0x75, 0x70,
	}

	assert.Equal(t, expected, res)
}

func TestEncoder_EncodeRawWithEventId(t *testing.T) {
	e := transport.NewEncoder(nil)
	e.EncodeRaw(transport.RawMessage{
		MessageId: transport.MessageId{
			SessionAlias: "alias",
			Sequence:     42,
			Direction:    transport.OutgoingDirection,
			Timestamp:    transport.TimestampFromTime(time.UnixMilli(1682420400000)),
		},
		EventID:  transport.NewEventID("B", "book", "scope", transport.TimestampFromTime(time.UnixMilli(1682420400000))),
		Protocol: "protocol",
		Metadata: map[string]string{
			"key": "value",
		},
		Body: []byte{41, 42, 43, 44, 45},
	}, 0)
	res := e.CompleteBatch("group", "book")

	expected := []byte{
		0x32, // batch
		0xbc, 0x00, 0x00, 0x00,
		0x33, // groups
		0xa4, 0x00, 0x00, 0x00,
		0x28, // group
		0x9f, 0x00, 0x00, 0x00,
		0x29, // msg list
		0x9a, 0x00, 0x00, 0x00,
		0x14, // raw msg
		0x95, 0x00, 0x00, 0x00,
		0x0a, // msg id
		0x33, 0x00, 0x00, 0x00,
		0x67, // alias
		0x05, 0x00, 0x00, 0x00,
		0x61, 0x6c, 0x69, 0x61, 0x73,
		0x68, // direction
		0x01, 0x00, 0x00, 0x00,
		0x02,
		0x69, // seq
		0x08, 0x00, 0x00, 0x00,
		0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6a, // sub seq
		0x00, 0x00, 0x00, 0x00,
		0x6b, // timestamp
		0x0c, 0x00, 0x00, 0x00,
		0xb0, 0xb2, 0x47, 0x64, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x0b, // metadata
		0x12, 0x00, 0x00, 0x00,
		0x02, // key
		0x03, 0x00, 0x00, 0x00,
		0x6b, 0x65, 0x79,
		0x02, // value
		0x05, 0x00, 0x00, 0x00,
		0x76, 0x61, 0x6c, 0x75, 0x65,
		0x0c, // protocol
		0x08, 0x00, 0x00, 0x00,
		0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
		0x15, // body
		0x05, 0x00, 0x00, 0x00,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d,
		0x10, // event ID
		0x2a, 0x00, 0x00, 0x00,
		0x0e, // id
		0x01, 0x00, 0x00, 0x00,
		0x42,
		0x65, // book
		0x04, 0x00, 0x00, 0x00,
		0x62, 0x6f, 0x6f, 0x6b,
		0x0f, // scope
		0x05, 0x00, 0x00, 0x00,
		0x73, 0x63, 0x6f, 0x70, 0x65,
		0x6b, // timestamp
		0x0c, 0x00, 0x00, 0x00,
		0xb0, 0xb2, 0x47, 0x64, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x65, // book
		0x04, 0x00, 0x00, 0x00,
		0x62, 0x6f, 0x6f, 0x6b,
		0x66, // group
		0x05, 0x00, 0x00, 0x00,
		0x67, 0x72, 0x6f, 0x75, 0x70,
	}

	assert.Equal(t, expected, res)
}

func TestEncoder_EncodeParsed(t *testing.T) {
	e := transport.NewEncoder(nil)
	e.EncodeParsed(transport.ParsedMessage{
		MessageId: transport.MessageId{
			SessionAlias: "alias",
			Sequence:     42,
			Direction:    transport.OutgoingDirection,
			Timestamp:    transport.TimestampFromTime(time.UnixMilli(1682420400000)),
			Subsequence:  []int32{1, 2},
		},
		Protocol: "protocol",
		Metadata: map[string]string{
			"key": "value",
		},
		Body: []byte{41, 42, 43, 44, 45},
	}, 0)
	res := e.CompleteBatch("group", "book")

	expected := []byte{
		0x32, // batch
		0xa4, 0x00, 0x00, 0x00,
		0x33, // groups
		0x8c, 0x00, 0x00, 0x00,
		0x28, // group
		0x87, 0x00, 0x00, 0x00,
		0x29, // msg list
		0x82, 0x00, 0x00, 0x00,
		0x1e, // parsed msg
		0x7d, 0x00, 0x00, 0x00,
		0x0a, // msg id
		0x45, 0x00, 0x00, 0x00,
		0x67, // alias
		0x05, 0x00, 0x00, 0x00,
		0x61, 0x6c, 0x69, 0x61, 0x73,
		0x68, // direction
		0x01, 0x00, 0x00, 0x00,
		0x02,
		0x69, // seq
		0x08, 0x00, 0x00, 0x00,
		0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x6a, // sub seq
		0x12, 0x00, 0x00, 0x00,
		0x03, // sub seq 1
		0x04, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00,
		0x03, // sub seq 2
		0x04, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00,
		0x6b, // timestamp
		0x0c, 0x00, 0x00, 0x00,
		0xb0, 0xb2, 0x47, 0x64, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x0b, // metadata
		0x12, 0x00, 0x00, 0x00,
		0x02, // key
		0x03, 0x00, 0x00, 0x00,
		0x6b, 0x65, 0x79,
		0x02, // value
		0x05, 0x00, 0x00, 0x00,
		0x76, 0x61, 0x6c, 0x75, 0x65,
		0x0c, // protocol
		0x08, 0x00, 0x00, 0x00,
		0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
		0x0d, // message type
		0x00, 0x00, 0x00, 0x00,
		0x1f, // body
		0x05, 0x00, 0x00, 0x00,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d,
		0x65, // book
		0x04, 0x00, 0x00, 0x00,
		0x62, 0x6f, 0x6f, 0x6b,
		0x66, // group
		0x05, 0x00, 0x00, 0x00,
		0x67, 0x72, 0x6f, 0x75, 0x70,
	}

	assert.Equal(t, expected, res)
}

func TestEncoder_CompleteBatch(t *testing.T) {
	e := transport.NewEncoder(nil)
	batch := e.CompleteBatch("group", "book")
	expected := []byte{
		0x32, // batch
		0x22, 0x0, 0x0, 0x0,
		0x33, // groups
		0xa, 0x0, 0x0, 0x0,
		0x28, // group
		0x5, 0x0, 0x0, 0x0,
		0x29, // msg list
		0x0, 0x0, 0x0, 0x0,
		0x65, // book
		0x4, 0x0, 0x0, 0x0,
		0x62, 0x6f, 0x6f, 0x6b,
		0x66, // group
		0x5, 0x0, 0x0, 0x0,
		0x67, 0x72, 0x6f, 0x75, 0x70,
	}

	assert.Equal(t, expected, batch)
}

func TestEncoder_IsEmpty(t *testing.T) {
	td := []struct {
		name     string
		supplier func() transport.Encoder
		isEmpty  bool
	}{
		{
			name: "empty batch",
			supplier: func() transport.Encoder {
				return transport.NewEncoder(nil)
			},
			isEmpty: true,
		},
		{
			name: "batch with msg",
			supplier: func() transport.Encoder {
				e := transport.NewEncoder(nil)
				e.EncodeRaw(transport.RawMessage{
					MessageId: transport.MessageId{
						SessionAlias: "alias",
						Sequence:     42,
						Direction:    transport.OutgoingDirection,
						Timestamp:    transport.TimestampFromTime(time.UnixMilli(1682420400000)),
					},
					EventID:  transport.NewEventID("B", "book", "scope", transport.TimestampFromTime(time.UnixMilli(1682420400000))),
					Protocol: "protocol",
					Metadata: map[string]string{
						"key": "value",
					},
					Body: []byte{41, 42, 43, 44, 45},
				}, 0)
				return e
			},
		},
	}

	for _, tc := range td {
		t.Run(tc.name, func(t *testing.T) {
			e := tc.supplier()

			assert.Truef(t, e.IsEmpty() == tc.isEmpty, "unexpected empty result %v (%v)", e.IsEmpty(), tc.isEmpty)
		})
	}
}
